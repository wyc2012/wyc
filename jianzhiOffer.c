1.
/*求整数中的所有位中1的个数*/
2.
/*在O(1)时间删除单链表的某个节点*/
3.
/*复杂链表的复制*/
4.
/*
字符串的排列：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。
*/
5.
/*
把数组排成最小的数：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，求最小的数。例如输入数组{3， 32， 321}，则最小数为321323
*/
6.
/*
两个链表的第一个公共点
*/
7.
/*数组中只出现依次的数字，其它数字都出现两次*/
8.
/*（1）和为S的两个数字（2）和为S的连续正数序列
(1)输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和为s。输出任意一对。
（2）输入一个正数s，打印出所有和为s的连续正数序列（至少包含两个数）。例如输入15，由于1+2+3+4+5 = 4+5+6=7+8=15，所以结果打印出3个连续序列。
*/


1.
int numberof(int n)
{
  int count = 0;
  while(n)
  {
    ++count;
    n = (n - 1) & n;
  }
  return count;
}

2.
//(1)先把要删除的节点的后面的节点拷到要删除的节点，然后删除下面那个节点。
//(2)如果要删除的节点是怎么一个节点，则要从头遍历找到最后一个。再删除。

3.
//方法1：先按链表的线性连接方法进行复制，并且在复制的时候把老节点与新节点进行hash表的对应关系，然后再修改复杂指针到新的节点。
//方法2：把新建的节点放到老节点的后面，然后进行复杂指针的修改。最后再从原来的链表中去掉。

4.
//递归方法：先第一个元素取所有的情况，然后排列所有后面的元素。
void Permutation(char* pStr)
{
    if(pStr == NULL)
    {
      retrun;
    }
    
    Permutation(pStr, pStr);
}

void Permutation(char* pStr, char* pBegin)
{
  if(pBegin == '\0')
    printf("%s\n", pStr);
  else
  {
    for(char* pCh = pBegin;*pCh != '\o'; ++pCh)
    {
      char temp = *pBegin;
      *pBegin = *pCh;
      pCh = temp;
      
      Permutation(pStr, pBegin + 1);
      
      temp = *pCh;
      *pCh = *pBegin;
      *pBegin = temp;
    }
  }
}

5.
/*把原来的数组排列，排列的比较函数为：比较两个数在前和在后排列后的值谁大，谁小。*/

6.
/*先计算两个链表的长度，然后一个链表的指针比两一个快长度之差*/

7.
/*求数字而不是在数组中找打它的位置：把所有的数依次抑或运算*/

8.
/*
1.一个指针1在0位置，一个指针2在最后位置。两个值相加若小于所求值则指针1加1，若大于所求值指针2减1。
2.一个值1为0，一个值2为0。然后求之间值的和。如果小于所求值，则值2加1，如果大于所求值，则值1加1。知道两个值相等。
*/
