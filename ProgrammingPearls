1.
/*
产生k个从0到n-1的随机数，高效
*/
2.
/*
在第一次访问向量的某一项时进行初始化，而不是在开始的时候全部初始化。
*/
3.
/*
旋转数组abcdefgh  rotate(3, 8)后为defghabc
*/
4.
/*
如何在程序中使用哨兵来找出数组中的最大元素。
*/




/*1*/
for(int i = 0; i < n; ++i)
  x[i] = i;
for(int j = 0; j < k; ++j)
{
  swap(i, randint(i, n-1));
  print x[i];
}

/*2*/
Entry data[NUM];
unsigned char from[NUM];
unsigned char to[NUM];
int top = 0;
//访问第i项
if(from[i] < top && to[from[i]] == i)//已经初始化
{
  //正常的访问操作
}
else//还没初始化
{
  from[i] = top;
  to[top] = i;
  Init(data[i]);//data[i]的初始化
  top++;
}

/*3*/
//(1)只占用一个额外空间并且，把每一项移动对应的位置。最重要的是每一项只移动了一次。
//最大公约数的效果：为了移动所有的元素，最大公约数会行程循环。
void rotate(int size, int n)
{
  for(int i = 0; i < gcd(size, n); ++i)
  {
    int t = x[i];
    j = i;
    
    while(1)
    {
      k = j + size;
      if( k >= n)
        k -= n;
      if(k == i)
        break;
      x[j] = x[k];
      j = k;
    }
    x[j] = t;
  }
}
//(2)经典的方法。
void rotate(int size, int n)
{
  reverse(0, size - 1);
  reverse(size, n - 1);
  reverse(0, n - 1);
}


/*4*/
i = 0;
while(i < n)
{
  max = x[i];
  x[n] = max;
  ++i;
  while(x[i] < max)//此处不用管i要比n小的判断
    ++i;
}
